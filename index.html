<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azul - Online Multiplayer</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Raleway:wght@300;400;500;600&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PeerJS for WebRTC peer-to-peer connections -->
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <style>
        :root {
            /* Tile Colors - Rich and vibrant */
            --tile-blue: #2b7cba;
            --tile-blue-light: #4a9fd4;
            --tile-blue-dark: #1a5a8a;
            --tile-yellow: #d4a020;
            --tile-yellow-light: #e8bc40;
            --tile-yellow-dark: #a07810;
            --tile-red: #c43c3c;
            --tile-red-light: #e05555;
            --tile-red-dark: #8a2020;
            --tile-black: #1a3040;
            --tile-black-light: #2a4a5a;
            --tile-black-dark: #0a1820;
            --tile-teal: #40a8a0;
            --tile-teal-light: #60c8c0;
            --tile-teal-dark: #208880;
            
            /* UI Colors */
            --bg-primary: #0a1628;
            --bg-secondary: #101c30;
            --bg-tertiary: #182840;
            --bg-card: #1a2a44;
            --bg-card-hover: #223454;
            --accent-gold: #d4a030;
            --accent-gold-light: #f0c050;
            --accent-teal: #40a0b0;
            --accent-teal-light: #60c0d0;
            --text-primary: #f0f4f8;
            --text-secondary: #a0b0c0;
            --text-muted: #607080;
            --border-subtle: rgba(255,255,255,0.08);
            --border-light: rgba(255,255,255,0.15);
            --shadow-color: rgba(0,0,0,0.4);
            --glow-blue: rgba(43, 124, 186, 0.5);
            --glow-gold: rgba(212, 160, 48, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Raleway', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(64, 160, 176, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(212, 160, 48, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(43, 124, 186, 0.04) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 20px 30px;
            position: relative;
            z-index: 1;
        }

        /* Header */
        header {
            text-align: center;
            padding: 25px 0 35px;
            position: relative;
        }

        .logo {
            max-width: 260px;
            height: auto;
            margin-bottom: 20px;
            filter: drop-shadow(0 8px 25px rgba(0,0,0,0.5));
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .logo:hover {
            transform: scale(1.03) translateY(-2px);
            filter: drop-shadow(0 12px 35px rgba(0,0,0,0.6));
        }

        .game-info {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .game-info span {
            background: var(--bg-card);
            padding: 12px 28px;
            border-radius: 50px;
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
            box-shadow: 
                0 4px 15px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.05);
            transition: all 0.3s ease;
        }

        .game-info span strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .current-player {
            background: linear-gradient(135deg, var(--accent-gold) 0%, #c08020 100%) !important;
            color: #1a1a1a !important;
            border-color: var(--accent-gold-light) !important;
            box-shadow: 
                0 4px 20px rgba(212, 160, 48, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2) !important;
        }

        .current-player strong {
            color: #1a1a1a !important;
        }

        /* Factory Section */
        .factory-section {
            margin-bottom: 50px;
            padding: 30px;
            background: var(--bg-secondary);
            border-radius: 24px;
            border: 1px solid var(--border-subtle);
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .section-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            text-align: center;
            margin-bottom: 25px;
            color: var(--text-secondary);
            letter-spacing: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .factories-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            align-items: center;
        }

        .factory {
            width: 130px;
            height: 130px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            padding: 18px;
            gap: 10px;
            box-shadow: 
                0 8px 30px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.05),
                inset 0 -2px 10px rgba(0,0,0,0.3);
            border: 2px solid var(--border-light);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .factory::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-teal) 0%, transparent 50%, var(--accent-gold) 100%);
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: -1;
        }

        .factory:hover {
            transform: translateY(-8px) scale(1.05);
            border-color: var(--accent-teal);
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(64, 160, 176, 0.2);
        }

        .factory:hover::before {
            opacity: 0.6;
        }

        .center-pool {
            width: 180px;
            height: 180px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: center;
            padding: 25px;
            gap: 8px;
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255,255,255,0.05),
                inset 0 -3px 15px rgba(0,0,0,0.3);
            border: 3px solid var(--accent-gold);
            position: relative;
            transition: all 0.4s ease;
        }

        .center-pool::before {
            content: 'CENTER';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            color: var(--text-muted);
            letter-spacing: 4px;
            pointer-events: none;
            font-family: 'Raleway', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
        }

        .center-pool:not(:empty)::before {
            display: none;
        }

        .center-pool:hover {
            box-shadow: 
                0 15px 50px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(212, 160, 48, 0.15);
        }

        .first-player-token {
            width: 38px;
            height: 38px;
            background: linear-gradient(145deg, var(--accent-gold) 0%, #a07010 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            color: #1a1a1a;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            box-shadow: 
                0 4px 15px rgba(212, 160, 48, 0.4),
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .first-player-token:hover {
            transform: scale(1.15) rotate(10deg);
            box-shadow: 
                0 6px 25px rgba(212, 160, 48, 0.5);
        }

        /* Tiles - Premium 3D design */
        .tile {
            width: 38px;
            height: 38px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 1;
            z-index: 1;
        }

        .tile::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, transparent 100%);
            border-radius: 6px 6px 0 0;
            pointer-events: none;
            z-index: 2;
        }

        .tile:hover {
            transform: scale(1.2) translateY(-5px) rotateX(10deg);
            z-index: 10;
        }

        .tile.selected {
            animation: tileSelected 0.6s ease infinite;
        }

        @keyframes tileSelected {
            0%, 100% { transform: scale(1.1); box-shadow: 0 0 20px var(--glow-gold); }
            50% { transform: scale(1.15); box-shadow: 0 0 35px var(--glow-gold); }
        }

        /* Blue Tile */
        .tile.blue { 
            background: linear-gradient(145deg, var(--tile-blue-light) 0%, var(--tile-blue) 50%, var(--tile-blue-dark) 100%);
            box-shadow: 
                0 6px 15px rgba(43, 124, 186, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.2),
                0 2px 0 var(--tile-blue-dark);
        }
        .tile.blue::before {
            background: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.5) 5%, transparent 15%),
                linear-gradient(45deg, transparent 40%, rgba(255,255,255,0.4) 48%, rgba(255,255,255,0.4) 52%, transparent 60%),
                linear-gradient(-45deg, transparent 40%, rgba(255,255,255,0.4) 48%, rgba(255,255,255,0.4) 52%, transparent 60%),
                radial-gradient(circle at 50% 20%, rgba(255,255,255,0.35) 5%, transparent 12%),
                radial-gradient(circle at 50% 80%, rgba(255,255,255,0.35) 5%, transparent 12%),
                radial-gradient(circle at 20% 50%, rgba(255,255,255,0.35) 5%, transparent 12%),
                radial-gradient(circle at 80% 50%, rgba(255,255,255,0.35) 5%, transparent 12%);
        }
        .tile.blue:hover {
            box-shadow: 
                0 12px 30px rgba(43, 124, 186, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.2),
                0 2px 0 var(--tile-blue-dark);
        }

        /* Yellow Tile */
        .tile.yellow { 
            background: linear-gradient(145deg, var(--tile-yellow-light) 0%, var(--tile-yellow) 50%, var(--tile-yellow-dark) 100%);
            box-shadow: 
                0 6px 15px rgba(212, 160, 32, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.15),
                0 2px 0 var(--tile-yellow-dark);
        }
        .tile.yellow::before {
            background: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.4) 8%, transparent 15%),
                radial-gradient(ellipse 50% 25% at 50% 30%, rgba(160,120,16,0.5) 0%, transparent 100%),
                radial-gradient(ellipse 50% 25% at 50% 70%, rgba(160,120,16,0.5) 0%, transparent 100%),
                radial-gradient(circle at 25% 25%, rgba(160,120,16,0.4) 8%, transparent 20%),
                radial-gradient(circle at 75% 25%, rgba(160,120,16,0.4) 8%, transparent 20%),
                radial-gradient(circle at 25% 75%, rgba(160,120,16,0.4) 8%, transparent 20%),
                radial-gradient(circle at 75% 75%, rgba(160,120,16,0.4) 8%, transparent 20%);
        }
        .tile.yellow:hover {
            box-shadow: 
                0 12px 30px rgba(212, 160, 32, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.15),
                0 2px 0 var(--tile-yellow-dark);
        }

        /* Red Tile */
        .tile.red { 
            background: linear-gradient(145deg, var(--tile-red-light) 0%, var(--tile-red) 50%, var(--tile-red-dark) 100%);
            box-shadow: 
                0 6px 15px rgba(196, 60, 60, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.2),
                0 2px 0 var(--tile-red-dark);
        }
        .tile.red::before {
            background: 
                radial-gradient(circle at 35% 35%, rgba(255,255,255,0.15) 0%, transparent 40%);
        }
        .tile.red:hover {
            box-shadow: 
                0 12px 30px rgba(196, 60, 60, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.2),
                0 2px 0 var(--tile-red-dark);
        }

        /* Black/Dark Tile */
        .tile.black { 
            background: linear-gradient(145deg, var(--tile-black-light) 0%, var(--tile-black) 50%, var(--tile-black-dark) 100%);
            box-shadow: 
                0 6px 15px rgba(26, 48, 64, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.3),
                0 2px 0 var(--tile-black-dark);
        }
        .tile.black::before {
            background: 
                conic-gradient(from 0deg at 50% 50%, 
                    rgba(80,140,160,0.5) 0deg, transparent 18deg,
                    rgba(80,140,160,0.5) 45deg, transparent 63deg,
                    rgba(80,140,160,0.5) 90deg, transparent 108deg,
                    rgba(80,140,160,0.5) 135deg, transparent 153deg,
                    rgba(80,140,160,0.5) 180deg, transparent 198deg,
                    rgba(80,140,160,0.5) 225deg, transparent 243deg,
                    rgba(80,140,160,0.5) 270deg, transparent 288deg,
                    rgba(80,140,160,0.5) 315deg, transparent 333deg
                ),
                radial-gradient(circle at 50% 50%, rgba(80,140,160,0.6) 12%, transparent 20%);
        }
        .tile.black:hover {
            box-shadow: 
                0 12px 30px rgba(26, 48, 64, 0.6),
                inset 0 -3px 6px rgba(0,0,0,0.3),
                0 2px 0 var(--tile-black-dark);
        }

        /* Teal Tile */
        .tile.teal { 
            background: linear-gradient(145deg, var(--tile-teal-light) 0%, var(--tile-teal) 50%, var(--tile-teal-dark) 100%);
            box-shadow: 
                0 6px 15px rgba(64, 168, 160, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.15),
                0 2px 0 var(--tile-teal-dark);
        }
        .tile.teal::before {
            background: 
                linear-gradient(45deg, transparent 38%, rgba(255,255,255,0.5) 46%, rgba(255,255,255,0.5) 54%, transparent 62%),
                linear-gradient(-45deg, transparent 38%, rgba(255,255,255,0.5) 46%, rgba(255,255,255,0.5) 54%, transparent 62%),
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.4) 6%, transparent 12%),
                radial-gradient(circle at 18% 18%, rgba(255,255,255,0.35) 4%, transparent 10%),
                radial-gradient(circle at 82% 18%, rgba(255,255,255,0.35) 4%, transparent 10%),
                radial-gradient(circle at 18% 82%, rgba(255,255,255,0.35) 4%, transparent 10%),
                radial-gradient(circle at 82% 82%, rgba(255,255,255,0.35) 4%, transparent 10%);
        }
        .tile.teal:hover {
            box-shadow: 
                0 12px 30px rgba(64, 168, 160, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.15),
                0 2px 0 var(--tile-teal-dark);
        }

        /* Players Section */
        .players-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(580px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .player-board {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.05);
            border: 1px solid var(--border-light);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .player-board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent-teal), transparent);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .player-board.active {
            border-color: var(--accent-gold);
            box-shadow: 
                0 25px 70px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(212, 160, 48, 0.15);
        }

        .player-board.active::before {
            opacity: 1;
            background: linear-gradient(90deg, transparent, var(--accent-gold), transparent);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 18px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .player-name {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-name::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--accent-teal);
            border-radius: 50%;
            opacity: 0.7;
        }

        .player-board.active .player-name::before {
            background: var(--accent-gold);
            box-shadow: 0 0 10px var(--glow-gold);
            animation: statusPulse 2s ease infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .player-score {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-gold);
            background: rgba(212, 160, 48, 0.1);
            padding: 8px 25px;
            border-radius: 12px;
            border: 1px solid rgba(212, 160, 48, 0.3);
            font-family: 'Cinzel', serif;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .player-score:hover {
            background: rgba(212, 160, 48, 0.15);
            border-color: rgba(212, 160, 48, 0.5);
        }

        .board-content {
            display: flex;
            gap: 35px;
            align-items: flex-start;
        }

        /* Pattern Lines */
        .pattern-lines {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pattern-row {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 10px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .pattern-row:hover {
            background: rgba(64, 160, 176, 0.1);
            border-color: rgba(64, 160, 176, 0.2);
        }

        .pattern-row.valid-target {
            background: rgba(212, 160, 48, 0.15);
            border-color: rgba(212, 160, 48, 0.4);
            animation: validGlow 1.5s ease infinite;
        }

        @keyframes validGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(212, 160, 48, 0.2); }
            50% { box-shadow: 0 0 25px rgba(212, 160, 48, 0.4); }
        }

        .pattern-slot {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-light);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .pattern-slot:hover {
            border-color: var(--accent-teal);
            background: rgba(64, 160, 176, 0.1);
        }

        .pattern-slot.filled {
            border-style: solid;
            border-color: transparent;
        }

        /* Wall */
        .wall {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            grid-template-rows: repeat(5, 40px);
            gap: 6px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
        }

        .wall-slot {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.08);
            opacity: 0.25;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .wall-slot:hover {
            opacity: 0.45;
            transform: scale(1.05);
        }

        .wall-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.6;
            z-index: 1;
        }

        .wall-slot::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, transparent 100%);
            border-radius: 6px 6px 0 0;
            z-index: 2;
        }

        .wall-slot.filled {
            opacity: 1;
            box-shadow: 
                0 6px 15px rgba(0, 0, 0, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.2);
        }

        /* Wall slot colors - matching tile colors */
        .wall-slot.blue { 
            background: linear-gradient(145deg, var(--tile-blue-light) 0%, var(--tile-blue) 50%, var(--tile-blue-dark) 100%);
        }
        .wall-slot.blue.filled {
            box-shadow: 
                0 6px 15px rgba(43, 124, 186, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.2);
        }
        .wall-slot.blue::before {
            background: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.4) 5%, transparent 15%),
                linear-gradient(45deg, transparent 40%, rgba(255,255,255,0.35) 48%, rgba(255,255,255,0.35) 52%, transparent 60%),
                linear-gradient(-45deg, transparent 40%, rgba(255,255,255,0.35) 48%, rgba(255,255,255,0.35) 52%, transparent 60%);
        }

        .wall-slot.yellow { 
            background: linear-gradient(145deg, var(--tile-yellow-light) 0%, var(--tile-yellow) 50%, var(--tile-yellow-dark) 100%);
        }
        .wall-slot.yellow.filled {
            box-shadow: 
                0 6px 15px rgba(212, 160, 32, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.15);
        }
        .wall-slot.yellow::before {
            background: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.35) 8%, transparent 15%),
                radial-gradient(ellipse 50% 25% at 50% 30%, rgba(160,120,16,0.4) 0%, transparent 100%),
                radial-gradient(ellipse 50% 25% at 50% 70%, rgba(160,120,16,0.4) 0%, transparent 100%);
        }

        .wall-slot.red { 
            background: linear-gradient(145deg, var(--tile-red-light) 0%, var(--tile-red) 50%, var(--tile-red-dark) 100%);
        }
        .wall-slot.red.filled {
            box-shadow: 
                0 6px 15px rgba(196, 60, 60, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.2);
        }
        .wall-slot.red::before {
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.12) 0%, transparent 40%);
        }

        .wall-slot.black { 
            background: linear-gradient(145deg, var(--tile-black-light) 0%, var(--tile-black) 50%, var(--tile-black-dark) 100%);
        }
        .wall-slot.black.filled {
            box-shadow: 
                0 6px 15px rgba(26, 48, 64, 0.5),
                inset 0 -3px 6px rgba(0,0,0,0.3);
        }
        .wall-slot.black::before {
            background: 
                conic-gradient(from 0deg at 50% 50%, 
                    rgba(80,140,160,0.4) 0deg, transparent 18deg,
                    rgba(80,140,160,0.4) 45deg, transparent 63deg,
                    rgba(80,140,160,0.4) 90deg, transparent 108deg,
                    rgba(80,140,160,0.4) 135deg, transparent 153deg,
                    rgba(80,140,160,0.4) 180deg, transparent 198deg,
                    rgba(80,140,160,0.4) 225deg, transparent 243deg,
                    rgba(80,140,160,0.4) 270deg, transparent 288deg,
                    rgba(80,140,160,0.4) 315deg, transparent 333deg
                ),
                radial-gradient(circle at 50% 50%, rgba(80,140,160,0.5) 12%, transparent 20%);
        }

        .wall-slot.teal { 
            background: linear-gradient(145deg, var(--tile-teal-light) 0%, var(--tile-teal) 50%, var(--tile-teal-dark) 100%);
        }
        .wall-slot.teal.filled {
            box-shadow: 
                0 6px 15px rgba(64, 168, 160, 0.4),
                inset 0 -3px 6px rgba(0,0,0,0.15);
        }
        .wall-slot.teal::before {
            background: 
                linear-gradient(45deg, transparent 38%, rgba(255,255,255,0.4) 46%, rgba(255,255,255,0.4) 54%, transparent 62%),
                linear-gradient(-45deg, transparent 38%, rgba(255,255,255,0.4) 46%, rgba(255,255,255,0.4) 54%, transparent 62%),
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.35) 6%, transparent 12%);
        }

        /* Floor Line */
        .floor-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border-subtle);
        }

        .floor-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-family: 'Raleway', sans-serif;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .floor-line {
            display: flex;
            gap: 8px;
        }

        .floor-slot {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border: 2px solid rgba(196, 60, 60, 0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: rgba(196, 80, 80, 0.8);
            font-weight: 700;
            position: relative;
            transition: all 0.3s ease;
        }

        .floor-slot:hover {
            border-color: rgba(196, 60, 60, 0.5);
            background: rgba(196, 60, 60, 0.1);
        }

        .floor-slot.filled {
            border-style: solid;
        }

        .floor-slot.first-player-floor {
            background: linear-gradient(145deg, var(--accent-gold) 0%, #a07010 100%);
            color: #1a1a1a;
            font-weight: bold;
            font-size: 1.1rem;
            border: 2px solid var(--accent-gold-light);
            box-shadow: 0 4px 15px rgba(212, 160, 48, 0.4);
        }

        /* Buttons */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 50px;
            padding-bottom: 30px;
        }

        .btn {
            font-family: 'Raleway', sans-serif;
            font-size: 0.9rem;
            padding: 16px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-gold) 0%, #c08020 100%);
            color: #1a1a1a;
            box-shadow: 
                0 6px 25px rgba(212, 160, 48, 0.35),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .btn-primary:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                0 12px 40px rgba(212, 160, 48, 0.45),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-light);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .btn-secondary:hover {
            background: var(--bg-card-hover);
            transform: translateY(-4px);
            border-color: var(--accent-teal);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.95);
            backdrop-filter: blur(15px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--bg-card);
            padding: 50px;
            border-radius: 24px;
            text-align: center;
            max-width: 500px;
            border: 1px solid var(--border-light);
            box-shadow: 
                0 30px 80px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.05);
            animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-30px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .modal h2 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: var(--accent-gold);
            margin-bottom: 20px;
        }

        .modal p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: var(--text-secondary);
        }

        .winner-score {
            font-size: 5rem;
            font-weight: 700;
            color: var(--accent-gold);
            margin: 20px 0;
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 40px var(--glow-gold);
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-card);
            padding: 16px 32px;
            border-radius: 50px;
            border: 1px solid var(--border-light);
            font-size: 0.95rem;
            color: var(--text-primary);
            z-index: 1001;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Instructions */
        .instructions {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px 30px;
            margin-bottom: 30px;
            border: 1px solid var(--border-subtle);
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }

        .instructions h3 {
            font-family: 'Playfair Display', serif;
            color: var(--accent-teal);
            margin-bottom: 12px;
            font-size: 1.1rem;
            letter-spacing: 1px;
        }

        .instructions p {
            font-size: 0.9rem;
            line-height: 1.8;
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .players-section {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            .logo {
                max-width: 180px;
            }
            
            .factory {
                width: 100px;
                height: 100px;
                padding: 12px;
            }
            
            .tile {
                width: 30px;
                height: 30px;
            }
            
            .pattern-slot, .wall-slot, .floor-slot {
                width: 34px;
                height: 34px;
            }
            
            .wall {
                grid-template-columns: repeat(5, 34px);
                grid-template-rows: repeat(5, 34px);
                padding: 10px;
            }

            .player-board {
                padding: 18px;
            }

            .game-info {
                gap: 10px;
            }

            .game-info span {
                padding: 10px 18px;
                font-size: 0.85rem;
            }
        }

        /* Animations */
        .tile-move {
            animation: tileMove 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes tileMove {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .score-pop {
            animation: scorePop 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes scorePop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: var(--accent-gold); }
            100% { transform: scale(1); }
        }

        /* Deselect button */
        .deselect-btn {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: linear-gradient(135deg, var(--tile-red) 0%, var(--tile-red-dark) 100%);
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 50px;
            font-family: 'Raleway', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(196, 60, 60, 0.4);
            z-index: 100;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            pointer-events: none;
        }

        .deselect-btn.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: all;
        }

        .deselect-btn:hover {
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 12px 40px rgba(196, 60, 60, 0.5);
        }

        /* Scoring overlay */
        .scoring-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: auto;
            padding: 30px;
            background: linear-gradient(180deg, rgba(10, 22, 40, 0.98) 0%, rgba(10, 22, 40, 0.8) 50%, transparent 100%);
            z-index: 500;
            display: none;
            justify-content: center;
            align-items: flex-start;
            flex-direction: column;
            pointer-events: none;
        }

        .scoring-overlay.show {
            display: flex;
            animation: overlayFadeIn 0.4s ease;
        }

        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .scoring-text {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: var(--accent-gold);
            text-align: center;
            width: 100%;
            animation: fadeInUp 0.5s ease;
            text-shadow: 0 4px 30px rgba(0, 0, 0, 0.8);
        }

        .scoring-details {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-top: 12px;
            text-align: center;
            width: 100%;
            animation: fadeInUp 0.5s ease 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tile-flying {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .wall-slot.just-placed {
            animation: wallPlace 0.6s ease;
        }

        @keyframes wallPlace {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .pattern-slot.placing {
            animation: patternPlace 0.4s ease;
        }

        @keyframes patternPlace {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }

        .player-board.scoring {
            animation: boardGlow 1s ease;
        }

        @keyframes boardGlow {
            0%, 100% { box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4); }
            50% { box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4), 0 0 60px rgba(212, 164, 76, 0.5); }
        }

        .score-float {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
            pointer-events: none;
            animation: floatUp 1s ease forwards;
            z-index: 100;
        }

        .score-float.negative {
            color: #f44336;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.3); }
        }

        /* Lobby Styles */
        .lobby-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .lobby-overlay.hidden {
            display: none;
        }

        .lobby-box {
            background: var(--bg-card);
            padding: 50px;
            border-radius: 24px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border-light);
            box-shadow: 
                0 30px 80px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }

        .lobby-box h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .lobby-box h2 {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--text-primary);
            margin-bottom: 30px;
        }

        .lobby-box p {
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .lobby-input {
            width: 100%;
            padding: 16px 24px;
            border: 2px solid var(--border-light);
            border-radius: 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.1rem;
            font-family: 'Raleway', sans-serif;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .lobby-input:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(212, 160, 48, 0.2);
        }

        .lobby-input::placeholder {
            color: var(--text-muted);
        }

        .lobby-status {
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid var(--border-subtle);
        }

        .lobby-status .waiting {
            color: var(--accent-teal);
            animation: pulse 2s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .lobby-status .player-list {
            margin-top: 15px;
            text-align: left;
        }

        .lobby-status .player-item {
            padding: 10px 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .lobby-status .player-item .dot {
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 1.5s ease infinite;
        }

        .lobby-status .player-item.you {
            border: 1px solid var(--accent-gold);
        }

        .room-code {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--accent-gold);
            letter-spacing: 5px;
            margin: 15px 0;
            user-select: all;
            cursor: pointer;
        }

        .room-code-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .copy-hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connection-status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .connection-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .connection-status .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .your-turn-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            background: linear-gradient(135deg, var(--accent-gold) 0%, #c08020 100%);
            color: #1a1a1a;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1rem;
            z-index: 100;
            box-shadow: 0 8px 30px rgba(212, 160, 48, 0.4);
            animation: bounceIn 0.5s ease;
        }

        .opponent-turn-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            background: var(--bg-card);
            color: var(--text-secondary);
            border-radius: 50px;
            font-weight: 500;
            font-size: 1rem;
            z-index: 100;
            border: 1px solid var(--border-light);
        }

        @keyframes bounceIn {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Lobby Overlay -->
    <div class="lobby-overlay" id="lobbyOverlay">
        <div class="lobby-box" id="lobbyBox">
            <h1>üé® AZUL</h1>
            <h2>Online Multiplayer</h2>
            
            <!-- Step 1: Enter Username -->
            <div id="usernameStep">
                <p>Enter your username to play:</p>
                <input type="text" class="lobby-input" id="usernameInput" placeholder="Your username" maxlength="15">
                <button class="btn btn-primary" onclick="setUsername()" style="width: 100%; margin-top: 10px;">Continue</button>
            </div>

            <!-- Step 2: Create or Join -->
            <div id="choiceStep" style="display: none;">
                <p>Hello, <strong id="displayUsername"></strong>!</p>
                <button class="btn btn-primary" onclick="createRoom()" style="width: 100%; margin-bottom: 15px;">üéÆ Create New Game</button>
                <button class="btn btn-secondary" onclick="showJoinStep()" style="width: 100%;">üîó Join Existing Game</button>
            </div>

            <!-- Step 3a: Waiting for opponent (host) -->
            <div id="waitingStep" style="display: none;">
                <p>Share this code with your friend:</p>
                <div class="room-code-label">ROOM CODE</div>
                <div class="room-code" id="roomCodeDisplay" onclick="copyRoomCode()">----</div>
                <div class="copy-hint">Click to copy</div>
                <div class="lobby-status">
                    <div class="waiting">‚è≥ Waiting for opponent to join...</div>
                    <div class="player-list" id="playerList"></div>
                </div>
            </div>

            <!-- Step 3b: Join with code -->
            <div id="joinStep" style="display: none;">
                <p>Enter the room code:</p>
                <input type="text" class="lobby-input" id="roomCodeInput" placeholder="XXXXXX" maxlength="6" style="text-transform: uppercase; text-align: center; letter-spacing: 5px; font-size: 1.5rem;">
                <button class="btn btn-primary" onclick="joinRoom()" style="width: 100%; margin-top: 10px;">Join Game</button>
                <button class="btn btn-secondary" onclick="showChoiceStep()" style="width: 100%; margin-top: 10px;">‚Üê Back</button>
            </div>
        </div>
    </div>
    <!-- Connection Status -->
    <div class="connection-status connected" id="connectionStatus" style="display: none;">
        <div class="dot"></div>
        <span>Connected</span>
    </div>

    <!-- Turn Indicator -->
    <div id="turnIndicator" style="display: none;"></div>

    <div class="game-container">
        <header>
            <img src="images.png" alt="AZUL" class="logo">
            <div class="game-info">
                <span>Round: <strong id="roundNum">1</strong></span>
                <span class="current-player">Current: <strong id="currentPlayer">Player 1</strong></span>
            </div>
        </header>

        <div class="instructions">
            <h3>How to Play</h3>
            <p>1. Click a tile from any factory or the center to select all tiles of that color.<br>
            2. Click on a pattern line (left side of your board) to place the tiles.<br>
            3. Completed rows score points when tiles move to the wall at round end.<br>
            4. Tiles that don't fit go to the floor line (negative points!).<br>
            5. Game ends when someone completes a horizontal row on their wall.</p>
        </div>

        <section class="factory-section">
            <h2 class="section-title">Factory Displays</h2>
            <div class="factories-container" id="factories">
                <!-- Factories will be generated here -->
            </div>
        </section>

        <section class="players-section" id="players">
            <!-- Player boards will be generated here -->
        </section>

        <div class="controls">
            <button class="btn btn-secondary" onclick="showRules()">üìñ Rules</button>
            <button class="btn btn-secondary" onclick="leaveGame()">üö™ Leave Game</button>
        </div>
    </div>

    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2>üèÜ Game Over!</h2>
            <p id="winnerText">Player 1 Wins!</p>
            <div class="winner-score" id="winnerScore">42</div>
            <p style="font-size: 1rem; opacity: 0.7;">points</p>
            <button class="btn btn-primary" onclick="leaveGame()" style="margin-top: 20px;">üö™ Leave Game</button>
            <button class="btn btn-secondary" onclick="playAgain()" style="margin-top: 10px;">üîÑ Play Again (Same Room)</button>
        </div>
    </div>

    <div class="modal" id="rulesModal">
        <div class="modal-content" style="max-width: 600px; text-align: left;">
            <h2 style="text-align: center;">üìñ Rules</h2>
            <div style="max-height: 400px; overflow-y: auto; padding: 20px 0; color: var(--text-secondary);">
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Objective</h3>
                <p style="margin-bottom: 20px;">Score the most points by completing patterns on your wall!</p>
                
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Taking Tiles</h3>
                <p style="margin-bottom: 20px;">On your turn, take ALL tiles of one color from a factory or the center. Remaining tiles go to the center.</p>
                
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Placing Tiles</h3>
                <p style="margin-bottom: 20px;">Place tiles in a pattern line (left side). Each row can only hold one color. The row size matches the row number (1-5 slots).</p>
                
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Wall Tiling</h3>
                <p style="margin-bottom: 20px;">When a pattern line is full, one tile moves to the matching wall position. Extra tiles are discarded.</p>
                
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Scoring</h3>
                <p style="margin-bottom: 20px;">Each tile scores 1 point plus 1 for each adjacent tile horizontally and vertically. Completed rows, columns, and color sets give bonuses!</p>
                
                <h3 style="color: var(--accent-gold); margin-bottom: 10px;">Floor Line</h3>
                <p style="margin-bottom: 20px;">Tiles that can't be placed go here. They give negative points: -1, -1, -2, -2, -2, -3, -3</p>
            </div>
            <button class="btn btn-primary" onclick="closeRules()" style="display: block; margin: 20px auto 0;">Got it!</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    <button class="deselect-btn" id="deselectBtn" onclick="deselectTiles()">‚úï Cancel Selection</button>
    
    <div class="scoring-overlay" id="scoringOverlay">
        <div class="scoring-text" id="scoringText">Scoring Round...</div>
        <div class="scoring-details" id="scoringDetails"></div>
    </div>

    <script>
        // PeerJS for WebRTC peer-to-peer connections
        // Uses PeerJS Cloud as signaling server (status: https://status.peerjs.com/)
        let peer = null;
        let conn = null;
        let pendingConnection = null;

        // Multiplayer State
        let myUsername = '';
        let myPlayerIndex = -1;
        let roomCode = '';
        let isHost = false;
        let gameStarted = false;
        let opponentUsername = '';

        // Game Constants
        const COLORS = ['blue', 'yellow', 'red', 'black', 'teal'];
        const TILES_PER_COLOR = 20;
        const FACTORY_COUNT = 5;
        const TILES_PER_FACTORY = 4;
        const FLOOR_PENALTIES = [-1, -1, -2, -2, -2, -3, -3];
        
        // Wall pattern (each row has colors shifted)
        const WALL_PATTERN = [
            ['blue', 'yellow', 'red', 'black', 'teal'],
            ['teal', 'blue', 'yellow', 'red', 'black'],
            ['black', 'teal', 'blue', 'yellow', 'red'],
            ['red', 'black', 'teal', 'blue', 'yellow'],
            ['yellow', 'red', 'black', 'teal', 'blue']
        ];

        // Game State
        let gameState = {
            players: [],
            currentPlayer: 0,
            factories: [],
            centerPool: [],
            tileBag: [],
            discardPile: [],
            round: 1,
            selectedTiles: null,
            selectedSource: null,
            firstPlayerToken: true,
            gameOver: false,
            isAnimating: false
        };

        // ==================== LOBBY FUNCTIONS ====================

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function setUsername() {
            const input = document.getElementById('usernameInput');
            const username = input.value.trim();
            if (username.length < 2) {
                showToast('Username must be at least 2 characters!');
                return;
            }
            myUsername = username;
            document.getElementById('displayUsername').textContent = username;
            document.getElementById('usernameStep').style.display = 'none';
            document.getElementById('choiceStep').style.display = 'block';
        }

        function showChoiceStep() {
            document.getElementById('joinStep').style.display = 'none';
            document.getElementById('choiceStep').style.display = 'block';
        }

        function showJoinStep() {
            document.getElementById('choiceStep').style.display = 'none';
            document.getElementById('joinStep').style.display = 'block';
        }

        function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;
            myPlayerIndex = 0;

            document.getElementById('choiceStep').style.display = 'none';
            document.getElementById('waitingStep').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = roomCode;

            showToast('Creating room...');

            try {
                // Create PeerJS peer with room code as ID
                const peerId = 'azul-' + roomCode;
                peer = new Peer(peerId, {
                    debug: 2,
                    config: {
                        iceServers: [
                            // STUN servers for NAT discovery
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' },
                            // Metered.ca free TURN servers
                            {
                                urls: 'turn:a.relay.metered.ca:80',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:80?transport=tcp',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:443',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turns:a.relay.metered.ca:443',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    console.log('Peer created with ID:', id);
                    updatePlayerList([myUsername]);
                    showToast('Room created! Share the code with your friend.');
                    updateConnectionStatus(true);
                });

                peer.on('connection', (connection) => {
                    console.log('Guest connecting...');
                    conn = connection;
                    setupConnection(conn);
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    if (err.type === 'unavailable-id') {
                        showToast('Room code already in use. Try again!');
                        roomCode = generateRoomCode();
                        document.getElementById('roomCodeDisplay').textContent = roomCode;
                        createRoom();
                    } else if (err.type === 'peer-unavailable') {
                        showToast('Connection failed. Please try again.');
                    } else {
                        showToast('Connection error: ' + err.type);
                    }
                });

                peer.on('disconnected', () => {
                    console.log('Peer disconnected, attempting reconnect...');
                    peer.reconnect();
                });

            } catch (err) {
                console.error('Error creating room:', err);
                showToast('Error creating room. Try again!');
            }
        }

        function setupConnection(connection) {
            connection.on('open', () => {
                console.log('Connection established!');
                updateConnectionStatus(true);
            });

            connection.on('data', (data) => {
                console.log('Received data:', data.type);
                handlePeerData(data);
            });

            connection.on('close', () => {
                console.log('Connection closed');
                if (gameStarted) {
                    showToast('Opponent disconnected!');
                    updateConnectionStatus(false);
                }
            });

            connection.on('error', (err) => {
                console.error('Connection error:', err);
                showToast('Connection error!');
            });
        }

        function handlePeerData(data) {
            switch(data.type) {
                case 'join':
                    opponentUsername = data.username;
                    updatePlayerList([myUsername, opponentUsername]);
                    showToast(opponentUsername + ' joined!');
                    
                    // Send acknowledgment
                    conn.send({ type: 'joinAck', username: myUsername });
                    
                    // Start game
                    if (!gameStarted) {
                        gameStarted = true;
                        setTimeout(() => {
                            initGameAsHost([myUsername, opponentUsername]);
                        }, 500);
                    }
                    break;

                case 'joinAck':
                    opponentUsername = data.username;
                    updatePlayerList([opponentUsername, myUsername]);
                    showToast('Connected to ' + opponentUsername + '!');
                    break;

                case 'gameState':
                    if (!isHost && data.state) {
                        if (!gameStarted) {
                            gameStarted = true;
                            document.getElementById('lobbyOverlay').classList.add('hidden');
                            updateTurnIndicator();
                        }
                        syncGameState(data.state);
                    }
                    break;

                case 'guestMove':
                    if (isHost && data.state) {
                        syncGameState(data.state);
                        sendGameState();
                    }
                    break;

                case 'playAgain':
                    if (isHost) {
                        const playerNames = [myUsername, opponentUsername];
                        initGameAsHost(playerNames);
                        document.getElementById('gameOverModal').classList.remove('show');
                        showToast('Starting new game...');
                    }
                    break;

                case 'leave':
                    showToast('Opponent left the game!');
                    updateConnectionStatus(false);
                    break;
            }
        }

        function joinRoom() {
            const input = document.getElementById('roomCodeInput');
            roomCode = input.value.trim().toUpperCase();
            
            if (roomCode.length !== 6) {
                showToast('Please enter a 6-character room code!');
                return;
            }

            isHost = false;
            myPlayerIndex = 1;

            showToast('Connecting to room...');
            
            // Show connecting state
            document.getElementById('joinStep').innerHTML = `
                <p>Connecting to room <strong>${roomCode}</strong>...</p>
                <div class="lobby-status">
                    <div class="waiting">‚è≥ Please wait...</div>
                </div>
                <button class="btn btn-secondary" onclick="cancelJoin()" style="width: 100%; margin-top: 10px;">Cancel</button>
            `;

            try {
                // Create peer for guest
                peer = new Peer({
                    debug: 2,
                    config: {
                        iceServers: [
                            // STUN servers for NAT discovery
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' },
                            // Metered.ca free TURN servers
                            {
                                urls: 'turn:a.relay.metered.ca:80',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:80?transport=tcp',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:443',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            },
                            {
                                urls: 'turns:a.relay.metered.ca:443',
                                username: 'e8dd65b92f7d3ab52410426a',
                                credential: 'uWdWNmkhvyaUu3j5'
                            }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    console.log('Guest peer created:', id);
                    
                    // Connect to host
                    const hostPeerId = 'azul-' + roomCode;
                    console.log('Connecting to host:', hostPeerId);
                    conn = peer.connect(hostPeerId, { reliable: true, serialization: 'json' });
                    
                    setupConnection(conn);
                    
                    conn.on('open', () => {
                        console.log('Connection opened to host!');
                        // Send join message
                        conn.send({ type: 'join', username: myUsername });
                        updatePlayerList([myUsername]);
                        showToast('Connected! Waiting for game to start...');
                        updateConnectionStatus(true);
                    });
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    if (err.type === 'peer-unavailable') {
                        showToast('Room not found! Check the code.');
                    } else if (err.type === 'network') {
                        showToast('Network error. Check your internet connection.');
                    } else {
                        showToast('Connection error: ' + err.type);
                    }
                    cancelJoin();
                });

                peer.on('disconnected', () => {
                    console.log('Peer disconnected, attempting reconnect...');
                    if (peer && !peer.destroyed) {
                        peer.reconnect();
                    }
                });

                // Timeout for connection - 120 seconds
                setTimeout(() => {
                    if (!conn || !conn.open) {
                        console.log('Connection timeout after 120 seconds');
                        showToast('Connection timeout. Possible causes:\n- Wrong room code\n- Host left\n- Firewall blocking connection');
                        cancelJoin();
                    }
                }, 120000);

            } catch (err) {
                console.error('Error joining room:', err);
                showToast('Error joining room. Try again!');
                cancelJoin();
            }
        }

        function cancelJoin() {
            if (conn) {
                conn.close();
                conn = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            // Reset join step UI
            document.getElementById('joinStep').innerHTML = `
                <p>Enter the room code:</p>
                <input type="text" class="lobby-input" id="roomCodeInput" placeholder="XXXXXX" maxlength="6" style="text-transform: uppercase; text-align: center; letter-spacing: 5px; font-size: 1.5rem;">
                <button class="btn btn-primary" onclick="joinRoom()" style="width: 100%; margin-top: 10px;">Join Game</button>
                <button class="btn btn-secondary" onclick="showChoiceStep()" style="width: 100%; margin-top: 10px;">‚Üê Back</button>
            `;
            
            // Re-add enter key listener
            setTimeout(() => {
                const input = document.getElementById('roomCodeInput');
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') joinRoom();
                    });
                }
            }, 100);
            
            showChoiceStep();
        }

        function sendGameState() {
            if (!conn || !conn.open) return;

            const stateToSync = {
                players: gameState.players,
                currentPlayer: gameState.currentPlayer,
                factories: gameState.factories,
                centerPool: gameState.centerPool,
                tileBag: gameState.tileBag,
                discardPile: gameState.discardPile,
                round: gameState.round,
                firstPlayerToken: gameState.firstPlayerToken,
                gameOver: gameState.gameOver
            };

            if (isHost) {
                conn.send({ type: 'gameState', state: stateToSync });
            } else {
                conn.send({ type: 'guestMove', state: stateToSync });
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.className = 'connection-status connected';
                status.innerHTML = '<div class="dot"></div><span>Connected</span>';
            } else {
                status.className = 'connection-status disconnected';
                status.innerHTML = '<div class="dot"></div><span>Disconnected</span>';
            }
            status.style.display = 'flex';
        }

        function updatePlayerList(players) {
            const listEl = document.getElementById('playerList');
            listEl.innerHTML = '';
            
            players.forEach((player, index) => {
                const isYou = player === myUsername;
                listEl.innerHTML += `
                    <div class="player-item ${isYou ? 'you' : ''}">
                        <div class="dot"></div>
                        <span>${player} ${isYou ? '(You)' : ''}</span>
                    </div>
                `;
            });
        }
        function copyRoomCode() {
            navigator.clipboard.writeText(roomCode).then(() => {
                showToast('Room code copied!');
            });
        }

        function leaveGame() {
            // Notify other player and cleanup PeerJS
            if (conn && conn.open) {
                conn.send({ type: 'leave' });
                conn.close();
            }
            conn = null;
            
            if (peer) {
                peer.destroy();
            }
            peer = null;
            
            // Reset everything
            gameStarted = false;
            roomCode = '';
            myPlayerIndex = -1;
            opponentUsername = '';
            
            document.getElementById('gameOverModal').classList.remove('show');
            document.getElementById('lobbyOverlay').classList.remove('hidden');
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('turnIndicator').style.display = 'none';
            
            // Reset lobby UI
            document.getElementById('usernameStep').style.display = 'block';
            document.getElementById('choiceStep').style.display = 'none';
            document.getElementById('waitingStep').style.display = 'none';
            document.getElementById('joinStep').style.display = 'none';
        }

        function playAgain() {
            if (conn && conn.open && isHost) {
                const playerNames = [myUsername, opponentUsername];
                initGameAsHost(playerNames);
                document.getElementById('gameOverModal').classList.remove('show');
                showToast('Starting new game...');
            } else if (conn && conn.open) {
                // Guest requests play again
                conn.send({ type: 'playAgain' });
                document.getElementById('gameOverModal').classList.remove('show');
                showToast('Waiting for host to start new game...');
            }
        }

        // ==================== GAME INITIALIZATION ====================

        function initGameAsHost(playerNames) {
            // Create tile bag
            gameState.tileBag = [];
            COLORS.forEach(color => {
                for (let i = 0; i < TILES_PER_COLOR; i++) {
                    gameState.tileBag.push(color);
                }
            });
            shuffleArray(gameState.tileBag);

            // Initialize players with actual usernames
            gameState.players = [
                createPlayer(playerNames[0]),
                createPlayer(playerNames[1])
            ];

            // Reset game state
            gameState.currentPlayer = 0;
            gameState.round = 1;
            gameState.centerPool = [];
            gameState.firstPlayerToken = true;
            gameState.selectedTiles = null;
            gameState.selectedSource = null;
            gameState.gameOver = false;
            gameState.discardPile = [];

            // Fill factories
            fillFactories();

            // Hide lobby, show game
            document.getElementById('lobbyOverlay').classList.add('hidden');
            document.getElementById('connectionStatus').style.display = 'flex';
            gameStarted = true;

            // Send game state to peer
            sendGameState();

            // Render
            render();
            updateTurnIndicator();
        }

        function syncGameState(remoteState) {
            // Don't sync if we're animating
            if (gameState.isAnimating) return;

            // Update local state from remote
            gameState.players = remoteState.players;
            gameState.currentPlayer = remoteState.currentPlayer;
            gameState.factories = remoteState.factories;
            gameState.centerPool = remoteState.centerPool || [];
            gameState.tileBag = remoteState.tileBag;
            gameState.discardPile = remoteState.discardPile || [];
            gameState.round = remoteState.round;
            gameState.firstPlayerToken = remoteState.firstPlayerToken;
            gameState.gameOver = remoteState.gameOver;

            // Clear local selection (each player has their own)
            gameState.selectedTiles = null;
            gameState.selectedSource = null;
            document.getElementById('deselectBtn').classList.remove('show');

            // Hide lobby if not already hidden
            document.getElementById('lobbyOverlay').classList.add('hidden');
            document.getElementById('connectionStatus').style.display = 'flex';

            // Render
            render();
            updateTurnIndicator();

            // Check for game over
            if (gameState.gameOver) {
                showGameOver();
            }
        }

        function syncToFirebase() {
            // Use PeerJS to send game state
            sendGameState();
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const isMyTurnNow = gameState.currentPlayer === myPlayerIndex;
            const currentPlayerName = gameState.players[gameState.currentPlayer]?.name || 'Player';

            if (isMyTurnNow) {
                indicator.className = 'your-turn-indicator';
                indicator.innerHTML = 'üéØ Your Turn!';
            } else {
                indicator.className = 'opponent-turn-indicator';
                indicator.innerHTML = `‚è≥ Waiting for ${currentPlayerName}...`;
            }
            indicator.style.display = 'block';
        }

        function isMyTurn() {
            return gameState.currentPlayer === myPlayerIndex;
        }

        // ==================== ORIGINAL GAME FUNCTIONS ====================

        function createPlayer(name) {
            return {
                name: name,
                score: 0,
                patternLines: [[], [], [], [], []],
                wall: Array(5).fill(null).map(() => Array(5).fill(false)),
                floorLine: [],
                hasFirstPlayerToken: false
            };
        }

        function fillFactories() {
            gameState.factories = [];
            for (let i = 0; i < FACTORY_COUNT; i++) {
                const factory = [];
                for (let j = 0; j < TILES_PER_FACTORY; j++) {
                    if (gameState.tileBag.length === 0) {
                        // Refill from discard pile
                        gameState.tileBag = [...gameState.discardPile];
                        gameState.discardPile = [];
                        shuffleArray(gameState.tileBag);
                    }
                    if (gameState.tileBag.length > 0) {
                        factory.push(gameState.tileBag.pop());
                    }
                }
                gameState.factories.push(factory);
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Render Functions
        function render() {
            renderFactories();
            renderPlayers();
            updateGameInfo();
        }

        function renderFactories() {
            const container = document.getElementById('factories');
            container.innerHTML = '';

            // Render factories
            gameState.factories.forEach((factory, index) => {
                const factoryEl = document.createElement('div');
                factoryEl.className = 'factory';
                factoryEl.dataset.index = index;

                factory.forEach((color, tileIndex) => {
                    const tile = createTileElement(color);
                    tile.dataset.factory = index;
                    tile.dataset.color = color;
                    
                    // Highlight if this tile's color is selected from this factory
                    if (gameState.selectedTiles && 
                        gameState.selectedSource &&
                        gameState.selectedSource.type === 'factory' &&
                        gameState.selectedSource.index === index &&
                        gameState.selectedSource.color === color) {
                        tile.classList.add('selected');
                    }
                    
                    tile.addEventListener('click', () => selectTile(index, color, 'factory'));
                    factoryEl.appendChild(tile);
                });

                container.appendChild(factoryEl);
            });

            // Render center pool
            const centerEl = document.createElement('div');
            centerEl.className = 'center-pool';

            if (gameState.firstPlayerToken) {
                const token = document.createElement('div');
                token.className = 'first-player-token';
                token.textContent = '1';
                token.title = 'First Player Token';
                centerEl.appendChild(token);
            }

            gameState.centerPool.forEach((color, index) => {
                const tile = createTileElement(color);
                tile.dataset.color = color;
                
                // Highlight if this tile's color is selected from center
                if (gameState.selectedTiles && 
                    gameState.selectedSource &&
                    gameState.selectedSource.type === 'center' &&
                    gameState.selectedSource.color === color) {
                    tile.classList.add('selected');
                }
                
                tile.addEventListener('click', () => selectTile(-1, color, 'center'));
                centerEl.appendChild(tile);
            });

            container.appendChild(centerEl);
        }

        function createTileElement(color) {
            const tile = document.createElement('div');
            tile.className = `tile ${color}`;
            return tile;
        }

        function renderPlayers() {
            const container = document.getElementById('players');
            container.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const boardEl = document.createElement('div');
                const isCurrentTurn = index === gameState.currentPlayer;
                const isMyBoard = index === myPlayerIndex;
                boardEl.className = `player-board ${isCurrentTurn ? 'active' : ''}`;
                
                const youLabel = isMyBoard ? ' (You)' : '';
                
                boardEl.innerHTML = `
                    <div class="player-header">
                        <div class="player-name">${player.name}${youLabel} ${player.hasFirstPlayerToken ? 'üëë' : ''}</div>
                        <div class="player-score">${player.score}</div>
                    </div>
                    <div class="board-content">
                        <div class="pattern-lines">
                            ${renderPatternLines(player, index)}
                        </div>
                        <div class="wall">
                            ${renderWall(player, index)}
                        </div>
                    </div>
                    <div class="floor-section">
                        <div class="floor-label">Floor Line (Penalty)</div>
                        <div class="floor-line">
                            ${renderFloorLine(player, index)}
                        </div>
                    </div>
                `;

                container.appendChild(boardEl);

                // Add event listeners for pattern rows
                if (index === gameState.currentPlayer) {
                    const patternRows = boardEl.querySelectorAll('.pattern-row');
                    patternRows.forEach((row, rowIndex) => {
                        row.addEventListener('click', () => placeTiles(rowIndex));
                    });
                }
            });
        }

        function renderPatternLines(player, playerIndex) {
            let html = '';
            for (let row = 0; row < 5; row++) {
                const size = row + 1;
                const tiles = player.patternLines[row];
                const isValid = playerIndex === gameState.currentPlayer && 
                               gameState.selectedTiles && 
                               canPlaceInRow(player, row, gameState.selectedTiles[0]);

                html += `<div class="pattern-row ${isValid ? 'valid-target' : ''}" data-row="${row}">`;
                
                for (let col = 0; col < size; col++) {
                    const tileIndex = size - 1 - col;
                    if (tileIndex < tiles.length) {
                        html += `<div class="pattern-slot filled tile ${tiles[tileIndex]}"></div>`;
                    } else {
                        html += `<div class="pattern-slot"></div>`;
                    }
                }
                
                html += '</div>';
            }
            return html;
        }

        function renderWall(player, playerIndex) {
            let html = '';
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const color = WALL_PATTERN[row][col];
                    const filled = player.wall[row][col];
                    html += `<div class="wall-slot ${color} ${filled ? 'filled' : ''}"></div>`;
                }
            }
            return html;
        }

        function renderFloorLine(player, playerIndex) {
            let html = '';
            for (let i = 0; i < 7; i++) {
                const tile = player.floorLine[i];
                const penalty = FLOOR_PENALTIES[i];
                if (tile) {
                    if (tile === 'first') {
                        html += `<div class="floor-slot filled first-player-floor">1</div>`;
                    } else {
                        html += `<div class="floor-slot filled tile ${tile}">${penalty}</div>`;
                    }
                } else {
                    html += `<div class="floor-slot">${penalty}</div>`;
                }
            }
            return html;
        }

        function updateGameInfo() {
            document.getElementById('roundNum').textContent = gameState.round;
            document.getElementById('currentPlayer').textContent = gameState.players[gameState.currentPlayer]?.name || 'Player';
        }

        // Game Logic
        function selectTile(sourceIndex, color, sourceType) {
            if (gameState.gameOver || gameState.isAnimating) return;

            // Check if it's this player's turn
            if (!isMyTurn()) {
                showToast("Wait for your turn!");
                return;
            }

            // If clicking the same selection, deselect (unhighlight)
            if (gameState.selectedTiles && 
                gameState.selectedSource && 
                gameState.selectedSource.index === sourceIndex && 
                gameState.selectedSource.type === sourceType &&
                gameState.selectedTiles[0] === color) {
                deselectTiles();
                return;
            }

            // Just highlight - don't move tiles yet
            let tiles = [];

            if (sourceType === 'factory') {
                const factory = gameState.factories[sourceIndex];
                tiles = factory.filter(t => t === color);
            } else {
                // Center pool
                tiles = gameState.centerPool.filter(t => t === color);
            }

            gameState.selectedTiles = tiles;
            gameState.selectedSource = { index: sourceIndex, type: sourceType, color: color };

            showToast(`Selected ${tiles.length} ${color} tile(s). Click a row to place.`);
            document.getElementById('deselectBtn').classList.add('show');
            render();
        }

        function deselectTiles() {
            if (!gameState.selectedTiles || gameState.isAnimating) return;
            
            gameState.selectedTiles = null;
            gameState.selectedSource = null;
            
            document.getElementById('deselectBtn').classList.remove('show');
            showToast('Selection cancelled.');
            render();
        }

        function highlightValidTargets() {
            // Already handled in render
        }

        function canPlaceInRow(player, rowIndex, color) {
            const row = player.patternLines[rowIndex];
            const maxSize = rowIndex + 1;
            
            // Row is full
            if (row.length >= maxSize) return false;
            
            // Row has different color
            if (row.length > 0 && row[0] !== color) return false;
            
            // Check if color already on wall for this row
            const wallCol = WALL_PATTERN[rowIndex].indexOf(color);
            if (player.wall[rowIndex][wallCol]) return false;
            
            return true;
        }

        function placeTiles(rowIndex) {
            if (!gameState.selectedTiles || gameState.selectedTiles.length === 0 || gameState.isAnimating) {
                if (!gameState.isAnimating) {
                    showToast('First select tiles from a factory or center!');
                }
                return;
            }

            // Check if it's this player's turn
            if (!isMyTurn()) {
                showToast("Wait for your turn!");
                return;
            }

            const player = gameState.players[gameState.currentPlayer];
            const color = gameState.selectedTiles[0];
            const tiles = [...gameState.selectedTiles];
            const source = gameState.selectedSource;

            if (rowIndex >= 0) {
                // Placing in pattern line
                if (!canPlaceInRow(player, rowIndex, color)) {
                    showToast('Cannot place here! Try another row or floor line.');
                    return;
                }
            }

            // NOW remove tiles from source and move remaining to center
            if (source.type === 'factory') {
                const factory = gameState.factories[source.index];
                const remainingTiles = factory.filter(t => t !== color);
                gameState.centerPool.push(...remainingTiles);
                gameState.factories[source.index] = [];
            } else {
                // Center pool - remove selected tiles
                gameState.centerPool = gameState.centerPool.filter(t => t !== color);
                
                // First player to take from center gets first player token
                if (gameState.firstPlayerToken) {
                    player.hasFirstPlayerToken = true;
                    player.floorLine.push('first');
                    gameState.firstPlayerToken = false;
                }
            }

            // Clear selection state before animation
            gameState.selectedTiles = null;
            gameState.selectedSource = null;
            document.getElementById('deselectBtn').classList.remove('show');

            if (rowIndex >= 0) {
                const maxSize = rowIndex + 1;
                const currentSize = player.patternLines[rowIndex].length;
                const spaceLeft = maxSize - currentSize;

                const tilesToPlace = tiles.slice(0, spaceLeft);
                const overflow = tiles.slice(spaceLeft);

                // Place tiles immediately (no animation for multiplayer sync)
                tilesToPlace.forEach(tile => {
                    player.patternLines[rowIndex].push(tile);
                });
                overflow.forEach(tile => {
                    if (player.floorLine.length < 7) {
                        player.floorLine.push(tile);
                    } else {
                        gameState.discardPile.push(tile);
                    }
                });

                // Check if round is over
                if (isRoundOver()) {
                    endRound();
                } else {
                    nextPlayer();
                    syncToFirebase();
                    render();
                    updateTurnIndicator();
                }
            } else {
                // Placing directly to floor
                tiles.forEach(tile => {
                    if (player.floorLine.length < 7) {
                        player.floorLine.push(tile);
                    } else {
                        gameState.discardPile.push(tile);
                    }
                });

                if (isRoundOver()) {
                    endRound();
                } else {
                    nextPlayer();
                    syncToFirebase();
                    render();
                    updateTurnIndicator();
                }
            }
        }

        function animateTilePlacement(player, rowIndex, tilesToPlace, overflow, callback) {
            gameState.isAnimating = true;
            render();

            let delay = 0;
            const delayIncrement = 200;

            // Place tiles one by one
            tilesToPlace.forEach((tile, i) => {
                setTimeout(() => {
                    player.patternLines[rowIndex].push(tile);
                    render();
                    
                    // Add animation class to the just-placed tile
                    const patternRows = document.querySelectorAll(`.player-board.active .pattern-row`);
                    if (patternRows[rowIndex]) {
                        const slots = patternRows[rowIndex].querySelectorAll('.pattern-slot.filled');
                        if (slots.length > 0) {
                            slots[slots.length - 1].classList.add('placing');
                        }
                    }
                }, delay);
                delay += delayIncrement;
            });

            // Place overflow to floor
            overflow.forEach((tile, i) => {
                setTimeout(() => {
                    if (player.floorLine.length < 7) {
                        player.floorLine.push(tile);
                    } else {
                        gameState.discardPile.push(tile);
                    }
                    render();
                }, delay);
                delay += delayIncrement;
            });

            // Finish animation
            setTimeout(() => {
                gameState.isAnimating = false;
                callback();
            }, delay + 100);
        }

        function animateFloorPlacement(player, tiles, callback) {
            gameState.isAnimating = true;
            render();

            let delay = 0;
            const delayIncrement = 150;

            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    if (player.floorLine.length < 7) {
                        player.floorLine.push(tile);
                    } else {
                        gameState.discardPile.push(tile);
                    }
                    render();
                }, delay);
                delay += delayIncrement;
            });

            setTimeout(() => {
                gameState.isAnimating = false;
                callback();
            }, delay + 100);
        }

        function isRoundOver() {
            const factoriesEmpty = gameState.factories.every(f => f.length === 0);
            const centerEmpty = gameState.centerPool.length === 0;
            return factoriesEmpty && centerEmpty;
        }

        function nextPlayer() {
            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
        }

        function endRound() {
            // Only host processes the round end to prevent conflicts
            if (!isHost) {
                // Non-host waits for state update from host
                return;
            }

            gameState.isAnimating = true;
            
            // Process scoring immediately for multiplayer
            processRoundScoring();
        }

        function processRoundScoring() {
            // Process all wall placements
            gameState.players.forEach((player, playerIndex) => {
                for (let row = 0; row < 5; row++) {
                    const maxSize = row + 1;
                    if (player.patternLines[row].length === maxSize) {
                        const color = player.patternLines[row][0];
                        const col = WALL_PATTERN[row].indexOf(color);
                        
                        // Place tile on wall
                        player.wall[row][col] = true;

                        // Score the tile
                        const points = scoreTile(player.wall, row, col);
                        player.score += points;

                        // Discard extra tiles
                        for (let i = 1; i < maxSize; i++) {
                            gameState.discardPile.push(color);
                        }

                        // Clear pattern line
                        player.patternLines[row] = [];
                    }
                }

                // Apply floor penalties
                let penalty = 0;
                player.floorLine.forEach((tile, index) => {
                    if (index < FLOOR_PENALTIES.length) {
                        penalty += FLOOR_PENALTIES[index];
                    }
                    if (tile !== 'first') {
                        gameState.discardPile.push(tile);
                    }
                });

                player.score += penalty;
                player.score = Math.max(0, player.score);
                player.floorLine = [];
            });

            // Check for game end
            if (checkGameEnd()) {
                endGame();
                return;
            }

            // Start new round
            gameState.round++;
            gameState.firstPlayerToken = true;

            // Find first player for next round
            const firstPlayerIndex = gameState.players.findIndex(p => p.hasFirstPlayerToken);
            if (firstPlayerIndex !== -1) {
                gameState.currentPlayer = firstPlayerIndex;
                gameState.players.forEach(p => p.hasFirstPlayerToken = false);
            }

            // Fill factories
            fillFactories();
            
            gameState.isAnimating = false;

            // Sync to Firebase
            syncToFirebase();

            // Render
            render();
            updateTurnIndicator();
            
            showToast(`üé≤ Round ${gameState.round} begins!`);
        }

        // Keep performScoringAnimation for visual purposes (not used in multiplayer)
        function performScoringAnimation(overlay) {
            const scoringDetails = document.getElementById('scoringDetails');
            let playerScores = [];

            gameState.players.forEach((player, playerIndex) => {
                let roundScore = 0;
                let wallMoves = [];

                // Collect all wall moves
                for (let row = 0; row < 5; row++) {
                    const maxSize = row + 1;
                    if (player.patternLines[row].length === maxSize) {
                        const color = player.patternLines[row][0];
                        const col = WALL_PATTERN[row].indexOf(color);
                        wallMoves.push({ row, col, color, patternSize: maxSize });
                    }
                }

                playerScores.push({
                    player,
                    playerIndex,
                    wallMoves,
                    floorPenalty: 0
                });
            });

            // Animate wall placements
            let totalDelay = 0;
            const moveDelay = 600;

            playerScores.forEach((ps, pIndex) => {
                ps.wallMoves.forEach((move, mIndex) => {
                    setTimeout(() => {
                        const player = ps.player;
                        const { row, col, color, patternSize } = move;

                        // Place tile on wall
                        player.wall[row][col] = true;

                        // Score the tile
                        const points = scoreTile(player.wall, row, col);
                        player.score += points;

                        // Discard extra tiles
                        for (let i = 1; i < patternSize; i++) {
                            gameState.discardPile.push(color);
                        }

                        // Clear pattern line
                        player.patternLines[row] = [];

                        // Update display
                        render();

                        // Show floating score
                        showFloatingScore(pIndex, row, col, points);

                        scoringDetails.textContent = `${player.name}: +${points} points!`;

                    }, totalDelay);
                    totalDelay += moveDelay;
                });
            });

            // Apply floor penalties after wall placements
            setTimeout(() => {
                scoringDetails.textContent = 'Applying floor penalties...';
            }, totalDelay);

            totalDelay += 500;

            gameState.players.forEach((player, pIndex) => {
                setTimeout(() => {
                    let penalty = 0;
                    player.floorLine.forEach((tile, index) => {
                        if (index < FLOOR_PENALTIES.length) {
                            penalty += FLOOR_PENALTIES[index];
                        }
                        if (tile !== 'first') {
                            gameState.discardPile.push(tile);
                        }
                    });

                    if (penalty < 0) {
                        player.score += penalty;
                        player.score = Math.max(0, player.score);
                        scoringDetails.textContent = `${player.name}: ${penalty} penalty`;
                        showFloatingPenalty(pIndex, penalty);
                    }

                    player.floorLine = [];
                    render();
                }, totalDelay);
                totalDelay += 400;
            });

            // Check for game end and start new round
            setTimeout(() => {
                overlay.classList.remove('show');

                if (checkGameEnd()) {
                    endGame();
                    return;
                }

                // Start new round
                gameState.round++;
                gameState.firstPlayerToken = true;

                // Find first player for next round
                const firstPlayerIndex = gameState.players.findIndex(p => p.hasFirstPlayerToken);
                if (firstPlayerIndex !== -1) {
                    gameState.currentPlayer = firstPlayerIndex;
                    gameState.players.forEach(p => p.hasFirstPlayerToken = false);
                }

                // Show new round message
                setTimeout(() => {
                    showToast(`üé≤ Round ${gameState.round} begins!`);
                    fillFactories();
                    gameState.isAnimating = false;
                    render();
                }, 300);

            }, totalDelay + 800);
        }

        function showFloatingScore(playerIndex, row, col, points) {
            const boards = document.querySelectorAll('.player-board');
            const board = boards[playerIndex];
            if (!board) return;

            const wallSlots = board.querySelectorAll('.wall-slot');
            const slotIndex = row * 5 + col;
            const slot = wallSlots[slotIndex];
            if (!slot) return;

            slot.classList.add('just-placed');

            const float = document.createElement('div');
            float.className = 'score-float';
            float.textContent = `+${points}`;
            float.style.left = slot.offsetLeft + 'px';
            float.style.top = slot.offsetTop + 'px';
            board.querySelector('.board-content').appendChild(float);

            setTimeout(() => {
                float.remove();
                slot.classList.remove('just-placed');
            }, 1000);
        }

        function showFloatingPenalty(playerIndex, penalty) {
            const boards = document.querySelectorAll('.player-board');
            const board = boards[playerIndex];
            if (!board) return;

            const floorSection = board.querySelector('.floor-section');
            if (!floorSection) return;

            const float = document.createElement('div');
            float.className = 'score-float negative';
            float.textContent = penalty;
            float.style.left = '50%';
            float.style.top = '0';
            floorSection.style.position = 'relative';
            floorSection.appendChild(float);

            setTimeout(() => float.remove(), 1000);
        }

        function scoreTile(wall, row, col) {
            let points = 0;
            let horizontal = 1;
            let vertical = 1;

            // Count horizontal
            for (let c = col - 1; c >= 0 && wall[row][c]; c--) horizontal++;
            for (let c = col + 1; c < 5 && wall[row][c]; c++) horizontal++;

            // Count vertical
            for (let r = row - 1; r >= 0 && wall[r][col]; r--) vertical++;
            for (let r = row + 1; r < 5 && wall[r][col]; r++) vertical++;

            if (horizontal > 1) points += horizontal;
            if (vertical > 1) points += vertical;
            if (horizontal === 1 && vertical === 1) points = 1;

            return points;
        }

        function checkGameEnd() {
            return gameState.players.some(player => {
                for (let row = 0; row < 5; row++) {
                    if (player.wall[row].every(cell => cell)) {
                        return true;
                    }
                }
                return false;
            });
        }

        function endGame() {
            gameState.gameOver = true;

            // Add bonus points
            gameState.players.forEach(player => {
                // Complete horizontal lines: +2 each
                for (let row = 0; row < 5; row++) {
                    if (player.wall[row].every(cell => cell)) {
                        player.score += 2;
                    }
                }

                // Complete vertical lines: +7 each
                for (let col = 0; col < 5; col++) {
                    let complete = true;
                    for (let row = 0; row < 5; row++) {
                        if (!player.wall[row][col]) {
                            complete = false;
                            break;
                        }
                    }
                    if (complete) player.score += 7;
                }

                // Complete color sets: +10 each
                COLORS.forEach(color => {
                    let count = 0;
                    for (let row = 0; row < 5; row++) {
                        const col = WALL_PATTERN[row].indexOf(color);
                        if (player.wall[row][col]) count++;
                    }
                    if (count === 5) player.score += 10;
                });
            });

            render();

            // Sync final state
            syncToFirebase();

            // Show winner
            showGameOver();
        }

        function showGameOver() {
            const winner = gameState.players.reduce((a, b) => a.score > b.score ? a : b);
            const loser = gameState.players.find(p => p !== winner);
            
            // Check for tie
            let winnerText = '';
            if (winner.score === loser.score) {
                winnerText = "It's a Tie!";
            } else {
                winnerText = `üéâ ${winner.name} Wins! üéâ`;
            }
            
            document.getElementById('winnerText').textContent = winnerText;
            document.getElementById('winnerScore').textContent = winner.score;
            document.getElementById('gameOverModal').classList.add('show');
        }

        function showRules() {
            document.getElementById('rulesModal').classList.add('show');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('show');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Add floor line click handler
        document.addEventListener('click', (e) => {
            if (e.target.closest('.floor-line') && gameState.selectedTiles && !gameState.isAnimating) {
                placeTiles(-1);
            }
        });

        // Close modals on outside click
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });
        });

        // Handle Enter key for inputs
        document.getElementById('usernameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') setUsername();
        });
        document.getElementById('roomCodeInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') joinRoom();
        });

        // Show lobby on page load (game starts when both players join)
        console.log('Azul Multiplayer ready! Waiting for players to join...');
    </script>
</body>
</html>
